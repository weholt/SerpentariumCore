{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Serpentarium Core","text":"<p>Serpentarium Core is a basic service container for python using the typing Protocol to define interfaces and type hints to resolve construction requirements for services.</p> <p>Thanks ChatGPT for that name ;-)</p>"},{"location":"#what-is-it","title":"What is it?","text":""},{"location":"#what-is-the-service-container-pattern","title":"What is the Service Container pattern?","text":"<p>The Service Container pattern is a design pattern that provides a centralized location for managing application services. A service is a class or module that provides a specific functionality, such as authentication, database access, or email sending. By separating services from components, we can achieve greater separation of concerns and better maintainability of our codebase.</p> <p>The Service Container pattern works by registering services with a central container, which can then be accessed by components as needed. This allows us to easily swap out services, add new services, or modify existing services without needing to modify individual components.</p> <p>Source</p>"},{"location":"#status","title":"Status:","text":"<ul> <li>Version: 0.2.1</li> <li>Status: In development / Alpha / Proof-of-consept</li> </ul>"},{"location":"#license","title":"License:","text":"<ul> <li>GPL-3 - GNU GENERAL PUBLIC LICENSE Version 3.</li> <li>A low-cost commercial license will be available later.</li> </ul> <p>Why dual licensing you might ask? Because the current open-source licensing does not work. It only benefits the big commercial companies and leave the independant, personal developer with nothing.</p> <p>This project will be available for commercial-non-GPL-use for a small fee, even smaller for independant developers like me (like $10) and not much more for companies (perhaps $100).</p>"},{"location":"#tested-with","title":"Tested with:","text":"<ul> <li>Python version 3.12.2</li> </ul>"},{"location":"#planned-features-and-todos","title":"Planned features and todo`s","text":"<ul> <li>Threads and async support? No clue on how thread-safe this is right now. Any help appreciated.</li> </ul>"},{"location":"#help","title":"Help","text":"<ul> <li>Read the documentation here</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Clone main repository:</p> <p><pre><code>    $ git clone https://github.com/weholt/serpentariumcore.git\n    $ cd serpentariumcore\n    $ pip install .\n</code></pre> Or</p> <pre><code>    $ pip install git+https://github.com/weholt/serpentariumcore.git\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>The following are actual test code, showing how to define a protocol and register an implemention of that protocol in the service container, and then later on, resolve the Protocol by name and get the implemention in return:</p> <pre><code>from serpentariumcore import ServiceContainer\n\n\nclass TheTalkingProtocol(Protocol):\n    def speak(self, sentence) -&gt; str: ...\n\n\nclass Teacher:\n    def speak(self, sentence) -&gt; str:\n        return f\"The teacher screams '{sentence}'.\"\n\n\nServiceContainer().register(TheTalkingProtocol, Teacher())\n\nif person := ServiceContainer().resolve(TheTalkingProtocol):\n    assert person.speak(sentence=\"The dog sits on a mat\") ==\n        \"The teacher screams 'The dog sits on a mat'.\"\n</code></pre>"},{"location":"#namespaces","title":"Namespaces","text":"<p>The service container also supports registering different implementations of the same protocol using namespaces:</p> <pre><code>class IoOperations(Protocol):\n    def read_file(self, filename: str) -&gt; str: ...\n\n\nclass ActualIoOperations:\n    def read_file(self, filename: str) -&gt; str:\n        return open(filename).read()\n\nclass TestingIoOperations:\n    def read_file(self, filename: str) -&gt; str:\n        return \"This is just some testing data\"\n\nServiceContainer().register(IoOperations, ActualIoOperations)\nServiceContainer().register(IoOperations, TestingIoOperations, namespace=\"test\")\n\nif io := ServiceContainer().resolve(IoOperations):\n    assert io.read_file(\"some_file.txt\") ==\n        \"Data from the actual file on disk called some_file.txt\"\n\nif io := ServiceContainer().resolve(IoOperations, namespace=\"test\"):\n    assert io.read_file(\"some_file.txt\") ==\n        \"This is just some testing data\"\n</code></pre> <p>You can also use a function to calculate the correct namespace to use, for instance checking some setting, like this:</p> <pre><code>class FancyLoggingBase(Protocol):\n    def log(self, msg: str, func: Callable[[str], str]) -&gt; str: ...\n\nclass LoggingTakingFunc:\n    def __init__(self, func: Callable[[str], str]) -&gt; None:\n        self.func = func\n\n    def log(self, msg: str) -&gt; str:\n        return self.func(msg)\n\ndef log_critical(msg: str) -&gt; str:\n    return f\"CRITICAL: {msg}\"\n\ndef log_debug(msg: str) -&gt; str:\n    return f\"DEBUG: {msg}\"\n\nServiceContainer().register(\n    FancyLoggingBase, LoggingTakingFunc(func=log_critical))\n\nServiceContainer().register(\n    FancyLoggingBase, LoggingTakingFunc(func=log_debug), namespace=\"debug\")\n\n# Simulate Django settings for test and prod\nclass Settings:\n    DEBUG = True\n\nsettings = Settings()\n\ndef resolve_namespace():\n    return settings.DEBUG and \"debug\" or None\n\nServiceContainer().set_namespace_resolver(resolve_namespace)\nif clueless_logger := ServiceContainer().resolve(FancyLoggingBase):\n    assert \"DEBUG\" in clueless_logger.log(msg=\"Should be debug\")\n\nsettings.DEBUG = False\nif clueless_logger := ServiceContainer().resolve(FancyLoggingBase):\n    assert \"CRITICAL\" in clueless_logger.log(msg=\"Should be critical\")\n</code></pre> <p>In the example above you can see that we do no change to the actual code using the service, but what implementation is used is calculated based on the settings.</p>"},{"location":"#automatic-dependency-resolving-and-construction-of-services","title":"Automatic dependency resolving and construction of services","text":"<p>We can also register services that depend on the implementation of other registered services, and the actual construction of instances of those services will be handled by the service container:</p> <pre><code>class IA(Protocol):\n\n    def go_a(self): ...\n\n\nclass IB(Protocol):\n\n    def go_b(self): ...\n\n\nclass IC(Protocol):\n\n    def go_c(self): ...\n\nclass A:\n    # Requires no other service\n    def __init__(self):\n        pass\n\n    def go_a(self):\n        return \"Go A!\"\n\n\nclass B:\n    # Requires some service that implements the IA protocol\n    def __init__(self, a: IA):\n        self.a = a\n\n    def go_b(self):\n        return \"Go B!\"\n\n\nclass C:\n    # Requires some services that implements both the IA and IB protocol\n    def __init__(self, a: IA, b: IB):\n        self.a: IA = a\n        self.b: IB = b\n\n    def go_c(self):\n        return self.a.go_a() + \" \" + self.b.go_b() + \" \" + \"And C as well!\"\n\n\nServiceContainer().register(IA, A)\nServiceContainer().register(IB, B)\nServiceContainer().register(IC, C)\nif c := ServiceContainer().resolve(IC):\n    assert c.go_c() == \"Go A! Go B! And C as well!\"\n</code></pre> <p>The service container is implemented as a Singleton, so you won't create a new instance each time you call <code>ServiceContainer()</code>; you get the same instance each time, including all the service registrations.</p>"},{"location":"#supply-your-service-with-additional-arguments","title":"Supply your service with additional arguments","text":"<p>Sometimes you need to provide some additional run-time arguments for your service, but you still want it to be constructed lazily. Using the ServiceArgument class can achieve this, like so:</p> <pre><code>from serpentariumcore import ServiceContainer, ServiceArgument\n\n\nclass IB(Protocol):\n\n    def howl(self) -&gt; str: ...\n\n\nclass B:\n\n    def howl(self) -&gt; str:\n        return \"YAHOOO!\"\n\n\nclass IA(Protocol):\n\n    def speak(self) -&gt; str: ...\n\n\nclass A:\n    def __init__(self, b: IB, **kwargs):\n        self.b = b\n        self.kwargs = kwargs\n\n    def speak(self) -&gt; str:\n        return f\"Kwargs: {self.kwargs} and {self.b.howl()}\"\n\nServiceContainer().register(IB, B)\nServiceContainer().register(IA,\n    ServiceArgument(some=\"foobar\", variable=\"something\").for_service(A))\n\nif res := ServiceContainer().resolve(IA):\n    spoken: str = res.speak()\n\n    # Here we test to see if both the foobar supplied as extra argument\n    # and the data from the required service IB are in the response\n    assert \"foobar\" in spoken and \"YAHOO\" in spoken\n</code></pre>"},{"location":"#contributing-reporting-issues","title":"Contributing &amp; Reporting Issues","text":"<ul> <li>Want to contribute directly to the source? Send me a line on thomas@weholt.org</li> <li>Any contribution is higly welcome, be it constructive critisism, ideas, testing and reporting bugs or anything else :-)</li> <li>Issues are reported here </li> </ul>"},{"location":"#release-notes","title":"Release notes","text":""},{"location":"#version-021","title":"Version 0.2.1","text":"<ul> <li>Added github pages for documentation. More docs coming soon :-)</li> </ul>"},{"location":"#version-020","title":"Version 0.2.0","text":"<ul> <li>Fixed a few bugs discovered while adding more unittest.</li> <li>Added support for lazy construction of instances.</li> <li>Added a ServiceArgument class for supplying your service with run-time arguments</li> </ul>"},{"location":"#version-010","title":"Version 0.1.0","text":"<ul> <li>First initial release.</li> </ul>"},{"location":"coverage/","title":"Coverage report","text":""}]}
